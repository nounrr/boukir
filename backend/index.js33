import express from 'express';
import cors from 'cors';
import morgan from 'morgan';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import path from 'path';
import employeesRouter from './routes/employees.js';
import authRouter from './routes/auth.js';
import categoriesRouter from './routes/categories.js';
import productsRouter from './routes/products.js';
import contactsRouter from './routes/contacts.js';
import vehiculesRouter from './routes/vehicules.js';
// Nouvelles routes pour chaque type de document
import commandesRouter from './routes/commandes.js';
import sortiesRouter from './routes/sorties.js';
import comptantRouter from './routes/comptant.js';
import devisRouter from './routes/devis.js';
import pool from './db/pool.js';
import mysql from 'mysql2/promise';
import bcrypt from 'bcryptjs';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.join(__dirname, '.env') });

const app = express();

app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

app.get('/api/health', (_req, res) => {
  res.json({ ok: true, service: 'bpukir-backend', ts: new Date().toISOString() });
});

// DB connectivity check
app.get('/api/db/ping', async (_req, res) => {
  try {
    const conn = await pool.getConnection();
    try {
      const [rows] = await conn.query('SELECT 1 AS ok');
      res.json({ ok: true, db: rows[0] });
    } finally {
      conn.release();
    }
  } catch (err) {
    res.status(500).json({
      ok: false,
      message: err?.message || 'DB error',
      code: err?.code,
      errno: err?.errno,
      sqlState: err?.sqlState,
      fatal: err?.fatal,
    });
  }
});

// DB info (no secrets)
app.get('/api/db/info', (_req, res) => {
  res.json({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    database: process.env.DB_NAME,
  });
});

app.use('/api/employees', employeesRouter);
app.use('/api/auth', authRouter);
app.use('/api/categories', categoriesRouter);
app.use('/api/products', productsRouter);
app.use('/api/contacts', contactsRouter);
app.use('/api/vehicules', vehiculesRouter);
// Nouvelles routes séparées par type de document
app.use('/api/commandes', commandesRouter);
app.use('/api/sorties', sortiesRouter);
app.use('/api/comptant', comptantRouter);
app.use('/api/devis', devisRouter);

app.use((req, res) => {
  res.status(404).json({ message: 'Not Found', path: req.path });
});

// eslint-disable-next-line no-unused-vars
app.use((err, _req, res, _next) => {
  console.error('Unhandled error:', err);
  const status = err.status || 500;
  const isProd = process.env.NODE_ENV === 'production';
  const payload = {
    message: err?.message || 'Internal Server Error',
  };
  if (!isProd) {
    payload.code = err?.code;
    payload.errno = err?.errno;
    payload.sqlState = err?.sqlState;
    payload.stack = err?.stack;
  }
  res.status(status).json(payload);
});

// Ensure DB and tables exist at startup
async function ensureDb() {
  const { DB_HOST, DB_PORT, DB_USER, DB_PASSWORD, DB_NAME } = process.env;
  const conn = await mysql.createConnection({
    host: DB_HOST || 'localhost',
    port: Number(DB_PORT || 3306),
    user: DB_USER || 'root',
    password: DB_PASSWORD || '',
    multipleStatements: true,
  });
  try {
    await conn.query(`CREATE DATABASE IF NOT EXISTS \`${DB_NAME}\``);
    await conn.query(`USE \`${DB_NAME}\``);
    await conn.query(`
      CREATE TABLE IF NOT EXISTS employees (
        id INT AUTO_INCREMENT PRIMARY KEY,
    nom_complet VARCHAR(255) DEFAULT NULL,
        cin VARCHAR(16) NOT NULL UNIQUE,
        date_embauche DATE DEFAULT NULL,
        role ENUM('PDG','Employé') DEFAULT NULL,
        password VARCHAR(255) NOT NULL,
        created_by INT NULL,
        updated_by INT NULL,
        created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
      )
    `);
    await conn.query(`
      CREATE TABLE IF NOT EXISTS categories (
        id INT AUTO_INCREMENT PRIMARY KEY,
        nom VARCHAR(255) NOT NULL,
        description TEXT NULL,
        created_by INT NULL,
        updated_by INT NULL,
        created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
      )
    `);
    await conn.query(`
      CREATE TABLE IF NOT EXISTS products (
        id INT AUTO_INCREMENT PRIMARY KEY,
        designation VARCHAR(255) NULL,
        categorie_id INT NOT NULL,
        quantite INT NOT NULL DEFAULT 0,
        prix_achat DECIMAL(10,2) NOT NULL DEFAULT 0,
        cout_revient_pourcentage DECIMAL(5,2) NOT NULL DEFAULT 0,
        cout_revient DECIMAL(10,2) NOT NULL DEFAULT 0,
        prix_gros_pourcentage DECIMAL(5,2) NOT NULL DEFAULT 0,
        prix_gros DECIMAL(10,2) NOT NULL DEFAULT 0,
        prix_vente_pourcentage DECIMAL(5,2) NOT NULL DEFAULT 0,
        prix_vente DECIMAL(10,2) NOT NULL DEFAULT 0,
        est_service TINYINT(1) NOT NULL DEFAULT 0,
        created_by INT NULL,
        updated_by INT NULL,
        created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        CONSTRAINT fk_products_category FOREIGN KEY (categorie_id) REFERENCES categories(id) ON DELETE RESTRICT ON UPDATE CASCADE
      )
    `);
    await conn.query(`
      CREATE TABLE IF NOT EXISTS contacts (
        id INT AUTO_INCREMENT PRIMARY KEY,
        nom_complet VARCHAR(255) NOT NULL,
        type ENUM('Client', 'Fournisseur') NOT NULL,
        telephone VARCHAR(20) NULL,
        email VARCHAR(255) NULL,
        adresse TEXT NULL,
        rib VARCHAR(50) NULL,
        ice VARCHAR(20) NULL,
        solde DECIMAL(10,2) NOT NULL DEFAULT 0,
        plafond DECIMAL(10,2) NULL,
        created_by INT NULL,
        updated_by INT NULL,
        created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
      )
    `);
    
    await conn.query(`
      CREATE TABLE IF NOT EXISTS vehicules (
        id INT AUTO_INCREMENT PRIMARY KEY,
        nom VARCHAR(255) NOT NULL,
        marque VARCHAR(100) NULL,
        modele VARCHAR(100) NULL,
        immatriculation VARCHAR(20) UNIQUE NOT NULL,
        annee INT NULL,
        type_vehicule ENUM('Camion', 'Camionnette', 'Voiture', 'Moto', 'Autre') NOT NULL DEFAULT 'Camion',
        capacite_charge DECIMAL(10,2) NULL,
        statut ENUM('Disponible', 'En service', 'En maintenance', 'Hors service') NOT NULL DEFAULT 'Disponible',
        created_by INT NULL,
        updated_by INT NULL,
        created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
      )
    `);
    
    
    // Suppression et recréation des tables restructurées
    try {
      await conn.query(`DROP TABLE IF EXISTS avoir_client_items`);
      await conn.query(`DROP TABLE IF EXISTS avoir_fournisseur_items`);
      await conn.query(`DROP TABLE IF EXISTS devis_items`);
      await conn.query(`DROP TABLE IF EXISTS comptant_items`);
      await conn.query(`DROP TABLE IF EXISTS sortie_items`);
      await conn.query(`DROP TABLE IF EXISTS commande_items`);
      await conn.query(`DROP TABLE IF EXISTS avoirs_client`);
      await conn.query(`DROP TABLE IF EXISTS avoirs_fournisseur`);
      await conn.query(`DROP TABLE IF EXISTS devis`);
      await conn.query(`DROP TABLE IF EXISTS bons_comptant`);
      await conn.query(`DROP TABLE IF EXISTS bons_sortie`);
      await conn.query(`DROP TABLE IF EXISTS bons_commande`);
      await conn.query(`DROP TABLE IF EXISTS bon_items`);
      await conn.query(`DROP TABLE IF EXISTS bons`);
      console.log('Tables supprimées pour restructuration');
    } catch (e) {
      console.warn('Erreur lors de la suppression des tables:', e?.message);
    }
    
    // ===== NOUVELLES TABLES SÉPARÉES PAR TYPE DE DOCUMENT (RESTRUCTURÉES) =====
    
    // Table des bons de commande
    await conn.query(`
      CREATE TABLE IF NOT EXISTS bons_commande (
        id INT PRIMARY KEY AUTO_INCREMENT,
        numero VARCHAR(50) UNIQUE NOT NULL,
        date_creation DATE NOT NULL,
        fournisseur_id INT,
        vehicule_id INT,
        lieu_chargement VARCHAR(255),
        montant_total DECIMAL(10,2) NOT NULL,
        statut ENUM('En attente', 'Validé', 'Livré', 'Facturé', 'Annulé') DEFAULT 'En attente',
        created_by INT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (fournisseur_id) REFERENCES contacts(id) ON DELETE SET NULL,
        FOREIGN KEY (vehicule_id) REFERENCES vehicules(id) ON DELETE SET NULL,
        FOREIGN KEY (created_by) REFERENCES employees(id)
      )
    `);

    // Table des bons de sortie
    await conn.query(`
      CREATE TABLE IF NOT EXISTS bons_sortie (
        id INT PRIMARY KEY AUTO_INCREMENT,
        numero VARCHAR(50) UNIQUE NOT NULL,
        date_creation DATE NOT NULL,
        client_id INT,
        vehicule_id INT,
        lieu_chargement VARCHAR(255),
        montant_total DECIMAL(10,2) NOT NULL,
        statut ENUM('En attente', 'Validé', 'Livré', 'Facturé', 'Annulé') DEFAULT 'En attente',
        created_by INT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (client_id) REFERENCES contacts(id) ON DELETE SET NULL,
        FOREIGN KEY (vehicule_id) REFERENCES vehicules(id) ON DELETE SET NULL,
        FOREIGN KEY (created_by) REFERENCES employees(id)
      )
    `);

    // Table des bons comptant
    await conn.query(`
      CREATE TABLE IF NOT EXISTS bons_comptant (
        id INT PRIMARY KEY AUTO_INCREMENT,
        numero VARCHAR(50) UNIQUE NOT NULL,
        date_creation DATE NOT NULL,
        client_id INT,
        vehicule_id INT,
        lieu_chargement VARCHAR(255),
        montant_total DECIMAL(10,2) NOT NULL,
        statut ENUM('En attente', 'Validé', 'Livré', 'Payé', 'Annulé') DEFAULT 'En attente',
        created_by INT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (client_id) REFERENCES contacts(id) ON DELETE SET NULL,
        FOREIGN KEY (vehicule_id) REFERENCES vehicules(id) ON DELETE SET NULL,
        FOREIGN KEY (created_by) REFERENCES employees(id)
      )
    `);

    // Table des devis
    await conn.query(`
      CREATE TABLE IF NOT EXISTS devis (
        id INT PRIMARY KEY AUTO_INCREMENT,
        numero VARCHAR(50) UNIQUE NOT NULL,
        date_creation DATE NOT NULL,
        client_id INT,
        montant_total DECIMAL(10,2) NOT NULL,
        lieu_chargement VARCHAR(255),
        statut ENUM('En attente', 'Envoyé', 'Accepté', 'Refusé', 'Expiré') DEFAULT 'En attente',
        created_by INT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (client_id) REFERENCES contacts(id) ON DELETE SET NULL,
        FOREIGN KEY (created_by) REFERENCES employees(id)
      )
    `);

    // Table des avoirs client
    await conn.query(`
      CREATE TABLE IF NOT EXISTS avoirs_client (
        id INT PRIMARY KEY AUTO_INCREMENT,
        numero VARCHAR(50) UNIQUE NOT NULL,
        date_creation DATE NOT NULL,
        client_id INT,
        montant_total DECIMAL(10,2) NOT NULL,
        lieu_chargement VARCHAR(255),
        statut ENUM('En attente', 'Validé', 'Appliqué', 'Annulé') DEFAULT 'En attente',
        created_by INT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (client_id) REFERENCES contacts(id) ON DELETE SET NULL,
        FOREIGN KEY (created_by) REFERENCES employees(id)
      )
    `);

    // Table des avoirs fournisseur
    await conn.query(`
      CREATE TABLE IF NOT EXISTS avoirs_fournisseur (
        id INT PRIMARY KEY AUTO_INCREMENT,
        numero VARCHAR(50) UNIQUE NOT NULL,
        date_creation DATE NOT NULL,
        fournisseur_id INT,
        montant_total DECIMAL(10,2) NOT NULL,
        lieu_chargement VARCHAR(255),
        statut ENUM('En attente', 'Validé', 'Appliqué', 'Annulé') DEFAULT 'En attente',
        created_by INT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (fournisseur_id) REFERENCES contacts(id) ON DELETE SET NULL,
        FOREIGN KEY (created_by) REFERENCES employees(id)
      )
    `);

    // ===== TABLES DES ITEMS POUR CHAQUE TYPE =====

    // Items des bons de commande
    await conn.query(`
      CREATE TABLE IF NOT EXISTS commande_items (
        id INT PRIMARY KEY AUTO_INCREMENT,
        bon_commande_id INT NOT NULL,
        product_id INT NOT NULL,
        quantite DECIMAL(10,2) NOT NULL,
        prix_unitaire DECIMAL(10,2) NOT NULL,
        remise_pourcentage DECIMAL(5,2) DEFAULT 0,
        remise_montant DECIMAL(10,2) DEFAULT 0,
        total DECIMAL(10,2) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (bon_commande_id) REFERENCES bons_commande(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id)
      )
    `);

    // Items des bons de sortie
    await conn.query(`
      CREATE TABLE IF NOT EXISTS sortie_items (
        id INT PRIMARY KEY AUTO_INCREMENT,
        bon_sortie_id INT NOT NULL,
        product_id INT NOT NULL,
        quantite DECIMAL(10,2) NOT NULL,
        prix_unitaire DECIMAL(10,2) NOT NULL,
        remise_pourcentage DECIMAL(5,2) DEFAULT 0,
        remise_montant DECIMAL(10,2) DEFAULT 0,
        total DECIMAL(10,2) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (bon_sortie_id) REFERENCES bons_sortie(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id)
      )
    `);

    // Items des bons comptant
    await conn.query(`
      CREATE TABLE IF NOT EXISTS comptant_items (
        id INT PRIMARY KEY AUTO_INCREMENT,
        bon_comptant_id INT NOT NULL,
        product_id INT NOT NULL,
        quantite DECIMAL(10,2) NOT NULL,
        prix_unitaire DECIMAL(10,2) NOT NULL,
        remise_pourcentage DECIMAL(5,2) DEFAULT 0,
        remise_montant DECIMAL(10,2) DEFAULT 0,
        total DECIMAL(10,2) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (bon_comptant_id) REFERENCES bons_comptant(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id)
      )
    `);

    // Items des devis
    await conn.query(`
      CREATE TABLE IF NOT EXISTS devis_items (
        id INT PRIMARY KEY AUTO_INCREMENT,
        devis_id INT NOT NULL,
        product_id INT NOT NULL,
        quantite DECIMAL(10,2) NOT NULL,
        prix_unitaire DECIMAL(10,2) NOT NULL,
        remise_pourcentage DECIMAL(5,2) DEFAULT 0,
        remise_montant DECIMAL(10,2) DEFAULT 0,
        total DECIMAL(10,2) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (devis_id) REFERENCES devis(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id)
      )
    `);

    // Items des avoirs client
    await conn.query(`
      CREATE TABLE IF NOT EXISTS avoir_client_items (
        id INT PRIMARY KEY AUTO_INCREMENT,
        avoir_client_id INT NOT NULL,
        product_id INT NOT NULL,
        quantite DECIMAL(10,2) NOT NULL,
        prix_unitaire DECIMAL(10,2) NOT NULL,
        total DECIMAL(10,2) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (avoir_client_id) REFERENCES avoirs_client(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id)
      )
    `);

    // Items des avoirs fournisseur
    await conn.query(`
      CREATE TABLE IF NOT EXISTS avoir_fournisseur_items (
        id INT PRIMARY KEY AUTO_INCREMENT,
        avoir_fournisseur_id INT NOT NULL,
        product_id INT NOT NULL,
        quantite DECIMAL(10,2) NOT NULL,
        prix_unitaire DECIMAL(10,2) NOT NULL,
        total DECIMAL(10,2) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (avoir_fournisseur_id) REFERENCES avoirs_fournisseur(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id)
      )
    `);
    
    console.log('Tables restructurées créées avec succès');
    
    // Idempotent alters to relax constraints and set defaults
    await conn.query("ALTER TABLE products MODIFY COLUMN designation VARCHAR(255) NULL");
    await conn.query("ALTER TABLE products MODIFY COLUMN prix_achat DECIMAL(10,2) NOT NULL DEFAULT 0");
    await conn.query("ALTER TABLE products MODIFY COLUMN cout_revient_pourcentage DECIMAL(5,2) NOT NULL DEFAULT 0");
    await conn.query("ALTER TABLE products MODIFY COLUMN cout_revient DECIMAL(10,2) NOT NULL DEFAULT 0");
    await conn.query("ALTER TABLE products MODIFY COLUMN prix_gros_pourcentage DECIMAL(5,2) NOT NULL DEFAULT 0");
    await conn.query("ALTER TABLE products MODIFY COLUMN prix_gros DECIMAL(10,2) NOT NULL DEFAULT 0");
    await conn.query("ALTER TABLE products MODIFY COLUMN prix_vente_pourcentage DECIMAL(5,2) NOT NULL DEFAULT 0");
    await conn.query("ALTER TABLE products MODIFY COLUMN prix_vente DECIMAL(10,2) NOT NULL DEFAULT 0");
    // Drop legacy 'reference' column if it exists (we now use id as reference)
    try {
      const [cols] = await conn.query(
        `SELECT COUNT(*) AS cnt FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = ? AND TABLE_NAME = 'products' AND COLUMN_NAME = 'reference'`,
        [DB_NAME]
      );
      if (cols[0]?.cnt > 0) {
        await conn.query("ALTER TABLE products DROP COLUMN reference");
      }
    } catch (e) {
      // ignore if cannot drop (e.g., insufficient privileges); app can still compute reference from id
      console.warn('Could not drop products.reference column:', e?.message);
    }
  // Ensure columns are nullable where required (idempotent alters)
  await conn.query("ALTER TABLE employees MODIFY COLUMN nom_complet VARCHAR(255) NULL DEFAULT NULL");
  await conn.query("ALTER TABLE employees MODIFY COLUMN date_embauche DATE NULL DEFAULT NULL");
  await conn.query("ALTER TABLE employees MODIFY COLUMN role ENUM('PDG','Employé') NULL DEFAULT NULL");
  await conn.query("ALTER TABLE employees MODIFY COLUMN password VARCHAR(255) NOT NULL");
  } finally {
    await conn.end();
  }
}

// Optional: migrate any plaintext passwords to bcrypt at startup (best-effort)
async function migratePasswords() {
  const connection = await pool.getConnection();
  try {
    const [rows] = await connection.query('SELECT id, password FROM employees');
    for (const r of rows) {
      const pwd = r.password || '';
      // bcrypt hashes start with $2a$ or $2b$ or $2y$
      if (!/^\$2[aby]\$/.test(pwd)) {
        const hashed = await bcrypt.hash(pwd, 10);
        await connection.query('UPDATE employees SET password = ? WHERE id = ?', [hashed, r.id]);
      }
    }
  } finally {
    connection.release();
  }
}

const PORT = process.env.PORT || 3001;
ensureDb()
  .then(() => migratePasswords())
  .then(() => {
    app.listen(PORT, () => {
      console.log(`API listening on http://localhost:${PORT}`);
    });
  })
  .catch((err) => {
    console.error('Failed to initialize database:', err);
    process.exit(1);
  });
